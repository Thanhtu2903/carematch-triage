# -*- coding: utf-8 -*-
"""Carematch Dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oIoZ5TM6liis-XHRZdfFIh-VBuNdqPpw
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
carematch = pd.read_csv("carematch_requests.csv")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile requirements.txt
# streamlit
# pandas
# matplotlib
# seaborn
# wordcloud
# scikit-learn
# yake
#

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import matplotlib.pyplot as plt
# import seaborn as sns
# 
# # --- Load dataset ---
# carematch = pd.read_csv("carematch_requests.csv")
# 
# # --- Dashboard Title ---
# st.title("üìä Carematch Dashboard")
# 
# # --- Show sample data ---
# st.subheader("Sample Data")
# st.write(carematch.head())
# 
# # --- Sidebar filter ---
# bins = st.sidebar.slider("Select number of bins for histogram", 5, 50, 20)
# # --- Descriptive Stats for All Variables ---
# st.header("üìä Descriptive Statistics (All Variables)")
# 
# # Descriptive stats for numeric + categorical variables
# desc_stats = carematch.describe(include="all").T   # transpose for readability
# 
# # Show as interactive table
# st.dataframe(desc_stats)
# 
# # --- Histogram Plot ---
# import streamlit as st
# import matplotlib.pyplot as plt
# import seaborn as sns
# 
# # --- First row: two charts ---
# col1, col2 = st.columns(2)
# 
# with col1:
#     st.subheader("Wait Time Distribution")
#     fig1, ax1 = plt.subplots()
#     sns.histplot(carematch['wait_time'], bins=20, kde=False, color='blue', ax=ax1)
#     ax1.set_xlabel("wait_time")
#     ax1.set_ylabel("Count")
#     st.pyplot(fig1)
# 
# with col2:
#     st.subheader("Chronic Conditions Distribution")
#     fig2, ax2 = plt.subplots()
#     sns.histplot(carematch['chronic_conditions_count'], bins=20, kde=False, color='blue', ax=ax2)
#     ax2.set_xlabel("chronic_conditions_count")
#     ax2.set_ylabel("Count")
#     st.pyplot(fig2)
# # --- SECTION: Boxplots ---
# st.header("üìä Wait Time by Categories")
# 
# # 1. Wait Time by Language Preference
# st.subheader("Wait Time by Language Preference")
# fig1, ax1 = plt.subplots(figsize=(10,6))
# sns.boxplot(data=carematch, x="language_pref", y="wait_time", palette="Set3", ax=ax1)
# ax1.set_title("Wait Time by Language Preference")
# ax1.set_xlabel("language_pref")
# ax1.set_ylabel("Wait Time")
# st.pyplot(fig1)
# 
# # 2. Wait Time by Provider Specialty
# st.subheader("Wait Time by Provider Specialty")
# fig2, ax2 = plt.subplots(figsize=(10,6))
# sns.boxplot(data=carematch, x="provider_specialty", y="wait_time", palette="Set3", ax=ax2)
# ax2.set_title("Wait Time by Provider Specialty")
# ax2.set_xlabel("provider_specialty")
# ax2.set_ylabel("Wait Time")
# st.pyplot(fig2)
# 
# # 3. Wait Time by Urgency Score
# st.subheader("Wait Time by Urgency Score")
# fig3, ax3 = plt.subplots(figsize=(10,6))
# sns.boxplot(data=carematch, x="urgency_score", y="wait_time", palette="Set3", ax=ax3)
# ax3.set_title("Wait Time by Urgency Score")
# ax3.set_xlabel("urgency_score")
# ax3.set_ylabel("Wait Time")
# st.pyplot(fig3)
# # --- SECTION: Countplots ---
# st.header("üìä Distribution of Categorical Variables")
# 
# col1, col2 = st.columns(2)   # put them side by side
# 
# # 1. Urgency Score Distribution
# with col1:
#     st.subheader("Urgency Score Distribution")
#     fig1, ax1 = plt.subplots(figsize=(8,5))
#     sns.countplot(data=carematch,
#                   x="urgency_score",
#                   order=carematch['urgency_score'].value_counts().index,
#                   ax=ax1)
#     ax1.set_title("Urgency Score Distribution")
#     ax1.set_xlabel("urgency_score")
#     ax1.set_ylabel("Count")
#     st.pyplot(fig1)
# 
# # 2. Mental Health Flag Distribution
# with col2:
#     st.subheader("Mental Health Flag Distribution")
#     fig2, ax2 = plt.subplots(figsize=(8,5))
#     sns.countplot(data=carematch,
#                   x="mental_health_flag",
#                   order=carematch['mental_health_flag'].value_counts().index,
#                   ax=ax2)
#     ax2.set_title("Mental Health Flag Distribution")
#     ax2.set_xlabel("mental_health_flag")
#     ax2.set_ylabel("Count")
#     ax2.set_xticklabels(ax2.get_xticklabels(), rotation=0)
#     st.pyplot(fig2)
# # --- Word Cloud ---
# st.header("‚òÅÔ∏è Word Cloud of Condition Summaries")
# 
# from wordcloud import WordCloud, STOPWORDS
# import re
# 
# # Preprocess text: lowercase, remove punctuation
# def preprocess(text):
#     if pd.isnull(text):
#         return ""
#     text = text.lower()
#     text = re.sub(r"[^a-z\s]", "", text)  # keep only letters
#     return text
# 
# # Apply preprocessing
# carematch['clean_summary'] = carematch['condition_summary'].apply(preprocess)
# 
# # Combine all rows into one string
# text = " ".join(carematch['clean_summary'])
# 
# # Define stopwords
# stopwords = set(STOPWORDS)
# stopwords.update(["need","ongoing","consultation","requesting","follow","patient"])
# 
# # Generate word cloud
# wordcloud = WordCloud(width=1200, height=600,
#                       background_color="white",
#                       stopwords=stopwords,
#                       colormap="tab10",
#                       collocations=True).generate(text)
# 
# # Plot and show in dashboard
# fig, ax = plt.subplots(figsize=(12,6))
# ax.imshow(wordcloud, interpolation="bilinear")
# ax.axis("off")
# ax.set_title("Word Cloud of Condition Summaries", fontsize=18)
# st.pyplot(fig)
# st.header("üìä Case & Provider Counts with Filters")
# 
# # --- Sidebar Filters ---
# st.sidebar.header("üîé Filters")
# 
# # Unique zip codes and providers
# zip_options = sorted(carematch['zip_code'].dropna().unique())
# provider_options = sorted(carematch['assigned_provider_id'].dropna().unique())
# 
# # Add filters
# selected_zip = st.sidebar.selectbox("Select a Zip Code", ["All"] + list(zip_options))
# selected_provider = st.sidebar.selectbox("Select a Provider ID", ["All"] + list(provider_options))
# 
# # --- 1. Cases per Zip Code ---
# cases_per_zip = carematch['zip_code'].value_counts().reset_index()
# cases_per_zip.columns = ['zip_code', 'total_cases']
# 
# providers_per_zip = (
#     carematch.groupby("zip_code")["assigned_provider_id"]
#              .nunique()
#              .reset_index(name="unique_providers")
# )
# 
# zip_summary = pd.merge(cases_per_zip, providers_per_zip, on="zip_code")
# 
# # Apply filter
# if selected_zip != "All":
#     zip_summary = zip_summary[zip_summary['zip_code'] == selected_zip]
# 
# st.subheader("üìç Zip Code Summary")
# st.dataframe(zip_summary)
# 
# # --- 2. Provider Case Counts ---
# provider_case_counts = carematch['assigned_provider_id'].value_counts().reset_index()
# provider_case_counts.columns = ['assigned_provider_id', 'total_cases_for_provider']
# 
# # Apply filter
# if selected_provider != "All":
#     provider_case_counts = provider_case_counts[
#         provider_case_counts['assigned_provider_id'] == selected_provider
#     ]
# 
# st.subheader("üë®‚Äç‚öïÔ∏è Provider Case Counts")
# st.dataframe(provider_case_counts)
# 
# # --- 3. Cases per Provider within each Zip ---
# zip_provider_cases = (
#     carematch.groupby(["zip_code", "assigned_provider_id"])
#              .size()
#              .reset_index(name="case_count")
# )
# 
# # Apply filters
# if selected_zip != "All":
#     zip_provider_cases = zip_provider_cases[zip_provider_cases['zip_code'] == selected_zip]
# 
# if selected_provider != "All":
#     zip_provider_cases = zip_provider_cases[zip_provider_cases['assigned_provider_id'] == selected_provider]
# 
# st.subheader("üìç+üë®‚Äç‚öïÔ∏è Cases per Provider within each Zip Code")
# st.dataframe(zip_provider_cases)
# st.header("üìÖ Monthly Case Counts per Provider")
# 
# # Ensure datetime
# carematch['request_timestamp'] = pd.to_datetime(carematch['request_timestamp'])
# carematch['request_month'] = carematch['request_timestamp'].dt.to_period("M")
# 
# # Monthly counts
# monthly_counts = (
#     carematch.groupby(['assigned_provider_id', 'request_month'])
#              .size()
#              .reset_index(name='case_count')
# )
# 
# # --- Sidebar filters ---
# st.sidebar.subheader("üìå Time Filters")
# 
# # Year filter
# years = sorted(carematch['request_timestamp'].dt.year.unique())
# selected_year = st.sidebar.selectbox("Select Year", ["All"] + list(years))
# 
# # Month filter
# months = sorted(carematch['request_timestamp'].dt.month.unique())
# selected_month = st.sidebar.selectbox("Select Month", ["All"] + list(months))
# 
# # Apply filters
# filtered = monthly_counts.copy()
# if selected_year != "All":
#     filtered = filtered[filtered['request_month'].dt.year == int(selected_year)]
# 
# if selected_month != "All":
#     filtered = filtered[filtered['request_month'].dt.month == int(selected_month)]
# 
# # --- Display table ---
# st.subheader("üìä Case Counts per Provider (Filtered by Month/Year)")
# st.dataframe(filtered)
# 
# import yake
# 
# # --- Keyword Extraction using YAKE ---
# kw_extractor = yake.KeywordExtractor(top=1, stopwords=None)
# 
# def extract_keyword(text):
#     if pd.isnull(text):
#         return None
#     keywords = kw_extractor.extract_keywords(text)
#     return keywords[0][0] if keywords else None
# 
# carematch["diagnosis"] = carematch["condition_summary"].apply(extract_keyword)
# st.header("ü©∫ Keyword Extraction from Condition Summaries")
# 
# # Show sample with extracted diagnosis keyword
# st.subheader("Sample Condition Summaries with Diagnosis Keyword")
# st.dataframe(carematch[["condition_summary", "diagnosis"]].head(50))
# 
# # Count frequency of keywords
# keyword_counts = carematch['diagnosis'].value_counts().reset_index()
# keyword_counts.columns = ["diagnosis_keyword", "count"]
# 
# st.subheader("Most Frequent Diagnosis Keywords")
# st.dataframe(keyword_counts.head(20))
# 
# # Visualize top keywords
# fig, ax = plt.subplots(figsize=(10,6))
# sns.barplot(data=keyword_counts.head(15), x="count", y="diagnosis_keyword", palette="viridis", ax=ax)
# ax.set_title("Top 15 Diagnosis Keywords")
# ax.set_xlabel("Count")
# ax.set_ylabel("Keyword")
# st.pyplot(fig)
# # --- CLUSTERING SECTION ---
# st.header("ü§ñ Patient Clustering Analysis")
# 
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.preprocessing import StandardScaler
# from sklearn.cluster import KMeans
# from sklearn.decomposition import PCA
# from scipy.sparse import hstack
# 
# # --- Feature preparation ---
# vectorizer = TfidfVectorizer(stop_words="english")
# X = vectorizer.fit_transform(carematch["diagnosis"].dropna())
# 
# structured = carematch.loc[
#     carematch["diagnosis"].notnull(),
#     ["urgency_score", "chronic_conditions_count", "mental_health_flag"]
# ]
# 
# scaler = StandardScaler()
# X_structured = scaler.fit_transform(structured)
# 
# X_cluster = hstack([X, X_structured])
# # --- Clustering: Elbow Method ---
# st.header("üìâ Elbow Method for Optimal k")
# 
# inertia = []
# K = range(2, 11)  # test k from 2 to 10 clusters
# 
# for k in K:
#     kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
#     kmeans.fit(X_cluster)
#     inertia.append(kmeans.inertia_)
# 
# # Plot elbow curve
# fig, ax = plt.subplots(figsize=(8, 6))
# ax.plot(K, inertia, "bo-")
# ax.set_xlabel("Number of clusters (k)")
# ax.set_ylabel("Inertia (Within-Cluster Sum of Squares)")
# ax.set_title("Elbow Method for Optimal k")
# 
# st.pyplot(fig)
# 
# # --- Select k interactively ---
# st.sidebar.subheader("‚öôÔ∏è Clustering Parameters")
# k = st.sidebar.slider("Select number of clusters (k)", min_value=2, max_value=10, value=4)
# 
# # --- Perform clustering ---
# kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
# carematch.loc[carematch["diagnosis"].notnull(), "cluster"] = kmeans.fit_predict(X_cluster)
# 
# # --- PCA visualization ---
# st.subheader("üìä PCA Visualization of Clusters")
# pca = PCA(n_components=2, random_state=42)
# X_pca = pca.fit_transform(X.toarray())
# 
# fig1, ax1 = plt.subplots(figsize=(8,6))
# sns.scatterplot(
#     x=X_pca[:,0], y=X_pca[:,1],
#     hue=carematch.loc[carematch["diagnosis"].notnull(), "cluster"],
#     palette="tab10", ax=ax1
# )
# ax1.set_title(f"Patient Clusters (k={k})")
# ax1.set_xlabel("PCA 1")
# ax1.set_ylabel("PCA 2")
# ax1.legend(title="Cluster")
# st.pyplot(fig1)
# 
# # --- Cluster insights ---
# st.subheader("üìë Cluster Insights")
# for c in range(k):
#     subset = carematch[carematch["cluster"] == c]
#     st.markdown(f"### üîπ Cluster {c} Summary")
#     st.write("**Top Diagnoses:**")
#     st.write(subset["diagnosis"].value_counts().head(5))
#     st.write("**Avg Urgency:**", round(subset["urgency_score"].mean(), 2))
#     st.write("**Avg Chronic Conditions:**", round(subset["chronic_conditions_count"].mean(), 2))
#     st.write("**Mental Health Flag %:**", round(subset["mental_health_flag"].mean()*100, 2), "%")
# 
# # --- Wait time by cluster ---
# st.subheader("‚è±Ô∏è Wait Time Distribution by Cluster")
# fig2, ax2 = plt.subplots(figsize=(8,6))
# sns.boxplot(x="cluster", y="wait_time", data=carematch, ax=ax2)
# ax2.set_title("Wait Time Distribution by Cluster")
# st.pyplot(fig2)
# 
# # --- Provider specialty by cluster ---
# st.subheader("üè• Provider Specialty Distribution by Cluster")
# fig3, ax3 = plt.subplots(figsize=(12,6))
# sns.countplot(x="cluster", hue="provider_specialty", data=carematch, ax=ax3)
# ax3.set_title("Provider Specialty Distribution by Cluster")
# ax3.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
# st.pyplot(fig3)
# 
# 
#